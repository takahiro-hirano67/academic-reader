This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.gitignore
backend/.env.example
backend/.python-version
backend/Dockerfile
backend/main.py
backend/pyproject.toml
backend/src/core/config.py
backend/src/core/model_setup.py
backend/src/services/academic/academic_api.py
backend/src/services/academic/academic_store.py
backend/src/services/academic/supports/academic_parser.py
docker-compose.yml
frontend/.env.local.example
frontend/.gitignore
frontend/app/favicon.ico
frontend/app/globals.css
frontend/app/layout.tsx
frontend/app/page.tsx
frontend/components/layout/Header.tsx
frontend/components/ui/CopyButton.tsx
frontend/components/ui/ImageModal.tsx
frontend/components/ui/MarkdownViewer.tsx
frontend/components/ui/Mermaid.tsx
frontend/Dockerfile
frontend/eslint.config.mjs
frontend/next.config.ts
frontend/package.json
frontend/postcss.config.mjs
frontend/styles/markdown_style.css
frontend/tailwind.config.js
frontend/tsconfig.json
README.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="frontend/.env.local.example">
NEXT_PUBLIC_API_URL = "http://localhost:8000"
</file>

<file path="frontend/components/layout/Header.tsx">
"use client";

import { Book } from "lucide-react";

export const Header = () => {

    return (
        <header
            className="flex items-center justify-between bg-white/80 backdrop-blur-md border-b border-gray-200/70 shadow-2xs z-50 transition-all duration-300"
            style={{ height: "52px" }}>
            <div className="flex items-center gap-2">
                <div className="flex items-center">
                    <div className="flex gap-2 pl-4 items-center w-[224px] h-[52px]">
                        {/* ロゴ部分 */}
                        <div className="flex items-center gap-2 ml-2">
                            <div className="w-7 h-7 bg-linear-to-br from-blue-500 to-purple-600 rounded-lg flex items-center justify-center">
                                <Book className="w-4 h-4 text-white" />
                            </div>
                            <span className="text-base font-semibold text-gray-800">Academic Reader</span>
                        </div>
                    </div>

                </div>
            </div>

        </header>
    );
};
</file>

<file path="frontend/components/ui/CopyButton.tsx">
"use client";

import { Check, Copy } from "lucide-react";
import { useState } from "react";

// ============================================================
// 生成されたテキストをクリップボードにコピーするボタンコンポーネント
// ============================================================

// 通常サイズ
export const CopyButton = ({
    text,
    className = "",
    label = "コピー",
}: {
    text: string;
    className?: string;
    label?: string;
}) => {
    const [isCopied, setIsCopied] = useState(false);

    const handleCopy = async () => {
        if (!text) return;

        try {
            await navigator.clipboard.writeText(text);
            setIsCopied(true);
            // 2秒後にアイコンを元に戻す
            setTimeout(() => {
                setIsCopied(false);
            }, 2000);
        } catch (err) {
            console.error("Failed to copy text: ", err);
        }
    };

    return (
        <button
            onClick={handleCopy}
            disabled={!text || isCopied}
            className={`flex items-center gap-2 px-3 py-1.5 text-xs font-medium rounded-md border transition-all 
                ${
                    isCopied
                        ? "bg-green-50 text-green-700 border-green-200"
                        : "bg-white text-slate-500 border-slate-200 hover:bg-slate-50 hover:text-slate-700"
                } ${className}`}
            title="クリップボードにコピー">
            {isCopied ? <Check size={14} /> : <Copy size={14} />}
            <span>{isCopied ? "コピー完了" : label}</span>
        </button>
    );
};

// 小さいコピーボタン（法人番号用）
export const SmallCopyButton = ({ text }: { text: string }) => {
    const [copied, setCopied] = useState(false);

    const handleCopy = async () => {
        if (!text) return;
        await navigator.clipboard.writeText(text);
        setCopied(true);
        setTimeout(() => setCopied(false), 1500);
    };

    return (
        <button
            onClick={handleCopy}
            disabled={!text}
            className={`
                inline-flex items-center justify-center
                w-7 h-7 rounded-md border
                transition-all
                ${
                    copied
                        ? "bg-green-50 border-green-200 text-green-600"
                        : "bg-white border-slate-200 text-slate-400 hover:bg-slate-50 hover:text-slate-600"
                }
            `}
            title={copied ? "コピーしました" : "コピー"}>
            {copied ? <Check size={14} /> : <Copy size={14} />}
        </button>
    );
};
</file>

<file path="frontend/components/ui/ImageModal.tsx">
"use client";

import { RotateCcw, RotateCw, X, ZoomIn, ZoomOut } from "lucide-react";
import { useEffect, useState } from "react";

interface ImageModalProps {
    isOpen: boolean;
    onClose: () => void;
    imageUrl: string | null;
    altText?: string;
}

// 画像拡大汎用モーダル
export const ImageModal = ({ isOpen, onClose, imageUrl, altText }: ImageModalProps) => {
    const [rotation, setRotation] = useState(0);
    const [scale, setScale] = useState(1);

    // モーダルが開くたびに状態をリセット
    useEffect(() => {
        if (isOpen) {
            setRotation(0);
            setScale(1);
        }
    }, [isOpen]);

    // ESCキーで閉じる
    useEffect(() => {
        const handleKeyDown = (e: KeyboardEvent) => {
            if (e.key === "Escape") onClose();
        };
        if (isOpen) {
            window.addEventListener("keydown", handleKeyDown);
        }
        return () => window.removeEventListener("keydown", handleKeyDown);
    }, [isOpen, onClose]);

    if (!isOpen || !imageUrl) return null;

    const handleRotateLeft = () => setRotation((prev) => prev - 90);
    const handleRotateRight = () => setRotation((prev) => prev + 90);
    const handleZoomIn = () => setScale((prev) => Math.min(prev + 0.25, 3)); // 最大3倍
    const handleZoomOut = () => setScale((prev) => Math.max(prev - 0.25, 0.5)); // 最小0.5倍

    return (
        <div
            className="fixed inset-0 z-100 flex items-center justify-center bg-black/40"
            onClick={onClose}
        >
            {/* コントロールバー */}
            <div
                className="absolute top-4 right-4 z-50 flex items-center gap-2 p-2 bg-black/40 rounded-full backdrop-blur-md border border-white/10"
                onClick={(e) => e.stopPropagation()}
            >
                <div className="flex gap-1 pr-2 border-r border-white/20">
                    <button
                        onClick={handleRotateLeft}
                        className="p-2 text-white/80 hover:text-white hover:bg-white/10 rounded-full transition-colors"
                        title="左に90度回転"
                    >
                        <RotateCcw size={20} />
                    </button>
                    <button
                        onClick={handleRotateRight}
                        className="p-2 text-white/80 hover:text-white hover:bg-white/10 rounded-full transition-colors"
                        title="右に90度回転"
                    >
                        <RotateCw size={20} />
                    </button>
                </div>

                <div className="flex gap-1 px-2 border-r border-white/20">
                    <button
                        onClick={handleZoomOut}
                        className="p-2 text-white/80 hover:text-white hover:bg-white/10 rounded-full transition-colors"
                        title="縮小"
                    >
                        <ZoomOut size={20} />
                    </button>
                    <button
                        onClick={handleZoomIn}
                        className="p-2 text-white/80 hover:text-white hover:bg-white/10 rounded-full transition-colors"
                        title="拡大"
                    >
                        <ZoomIn size={20} />
                    </button>
                </div>

                <button
                    onClick={onClose}
                    className="ml-1 p-2 bg-white/10 hover:bg-red-500/80 text-white rounded-full transition-colors"
                    title="閉じる (Esc)"
                >
                    <X size={20} />
                </button>
            </div>

            {/* 画像表示エリア */}
            <div
                className="relative w-full h-full flex items-center justify-center p-8 overflow-hidden"
                onClick={onClose} // 画像外クリックでも閉じる
            >
                {/* eslint-disable-next-line @next/next/no-img-element */}
                <img
                    src={imageUrl}
                    alt={altText || "Preview"}
                    onClick={(e) => e.stopPropagation()} // 画像クリックでは閉じない
                    style={{
                        transform: `rotate(${rotation}deg) scale(${scale})`,
                        transition: "transform 0.3s cubic-bezier(0.25, 0.8, 0.25, 1)",
                        maxWidth: "100%",
                        maxHeight: "100%",
                        objectFit: "contain",
                    }}
                    className="shadow-2xl select-none"
                    draggable={false}
                />
            </div>
            
            {/* 情報表示（左下） */}
            <div className="absolute bottom-6 left-6 text-white/70 text-sm font-mono bg-black/40 px-3 py-1 rounded-md backdrop-blur-md">
                {altText} • {Math.round(scale * 100)}% • {rotation}°
            </div>
        </div>
    );
};
</file>

<file path="frontend/components/ui/MarkdownViewer.tsx">
"use client";

import "@/styles/markdown_style.css";
import "katex/dist/katex.min.css"; // 数式用CSS

import { Check, Copy } from "lucide-react"; // アイコン用
import dynamic from "next/dynamic";
import React, { memo, useMemo, useState } from "react";
import ReactMarkdown from "react-markdown"; // Markdownレンダリング

// --- Plugins ---
import { Prism as SyntaxHighlighter } from "react-syntax-highlighter"; // コードハイライト
import { vs } from "react-syntax-highlighter/dist/esm/styles/prism"; // VSコード風のスタイル
import rehypeKatex from "rehype-katex"; // 数式描画ライブラリを利用してHTML化
import remarkBreaks from "remark-breaks"; // 改行を<br>として扱う
import remarkGfm from "remark-gfm"; // GitHub Flavored Markdown (GFM) の記法を適用
import { remarkAlert } from "remark-github-blockquote-alert"; // GitHubスタイルの警告表示適用
import remarkMath from "remark-math"; // 数式記法の認識（$E=mc^2$ や $$...$$など）

// Mermaidコンポーネントを動的インポート（SSR無効化・Loading表示付き）
// これにより、Mermaidが含まれないページでは巨大なライブラリが読み込まれない
const MermaidPreview = dynamic(() => import("./Mermaid"), {
    ssr: false,
    loading: () => <div className="p-4 text-gray-400 animate-pulse">Loading Diagram...</div>,
});

// ============================================================
// テキスト前処理関数
// ============================================================

const preprocessContent = (content: string) => {
    if (!content) return "";

    let processed = content;

    // 1. MathDelimiters normalization
    // Doclingなどが出力する \[ ... \] や \( ... \) を $$...$$ や $...$ に変換
    processed = processed.replace(/\\\[([\s\S]*?)\\\]/g, "$$$$$1$$$$");
    processed = processed.replace(/\\\(([\s\S]*?)\\\)/g, "$$$1$$");

    // 2. OCR Typos Fix
    // Docling特有の "M u t i { H e a d }" を "MultiHead" に修正
    if (processed.includes("M u t i { H e a d }")) {
        processed = processed.replace(/M u t i \{ H e a d \}/g, "\\text{MultiHead}");
    }

    // 3. KaTeX Aligned Fix
    // 数式内に '&' (整列) があり、かつ環境指定(\begin)がない場合、
    // KaTeXがエラーになるため、自動的に aligned 環境で囲む
    processed = processed.replace(/\$\$([\s\S]*?)\$\$/g, (match, equation) => {
        // 既に環境指定(\begin)がある場合は何もしない
        if (equation.includes("\\begin")) return match;

        // '&' (整列タブ) が含まれている場合、補正対象とする
        if (equation.includes("&")) {
            // $$ の内側に改行を入れ、aligned環境で囲むことで
            // remark-math にブロック数式として認識させ、かつ整列を有効にする
            return `$$\n\\begin{aligned}\n${equation}\n\\end{aligned}\n$$`;
        }

        return match;
    });

    // 4. Code Block normalization
    // コードブロックの ``` の直前に改行がないと正しくパースされない場合への対処
    processed = processed.replace(/([^\n])```/g, "$1\n```");

    return processed;
};

// ============================================================
// メインコンポーネント
// ============================================================

interface MarkdownViewerProps {
    content: string;
    className?: string;
}

const MarkdownViewer: React.FC<MarkdownViewerProps> = ({ content, className }) => {
    // メモ化して前処理を実行
    const processedContent = useMemo(() => preprocessContent(content), [content]);

    return (
        <div className={`markdown ${className || ""}`}>
            <ReactMarkdown
                remarkPlugins={[remarkGfm, remarkBreaks, remarkMath, remarkAlert]}
                rehypePlugins={[rehypeKatex]}
                components={{
                    // pタグをdivタグに置き換えて、Hydrationエラーを回避（pタグの中にdiv(コードブロック)が入るのを防ぐため）
                    p: ({ children }) => <div className="mb-4 leading-relaxed">{children}</div>,

                    // preタグは、中のcodeタグ(CodeBlock)がスタイルを持つため、ラッパーを外す
                    pre: ({ children }) => <>{children}</>,

                    // codeタグをカスタムコンポーネントに置き換え
                    code: CodeBlock,

                    // --- リンク制御（外部リンクを別タブで開く） ---
                    a: ({ node, ...props }) => (
                        <a
                            {...props}
                            target="_blank"
                            rel="noopener noreferrer"
                            className="text-blue-600 hover:underline cursor-pointer"
                        />
                    ),
                }}>
                {processedContent}
            </ReactMarkdown>
        </div>
    );
};
// 【メモ化して、contentが変わった時だけ再レンダリングする】
// ストリーミング時は頻繁に更新されるが、ReactのDiff検知により
// 変更部分以外の再描画コストを抑えらる。
export default memo(MarkdownViewer, (prev, next) => prev.content === next.content);

// -----------------------------------------------------------------------------
// コードブロック用コンポーネント（状態管理のために分離）
// -----------------------------------------------------------------------------
const CodeBlock = ({ node, inline, className, children, ...props }: any) => {
    const match = /language-(\w+)/.exec(className || "");
    const lang = match ? match[1] : "";
    const codeString = String(children).replace(/\n$/, "");
    const [isCopied, setIsCopied] = useState(false);

    // 【メモ】
    // react-markdown v9+ では inline プロパティが渡されないため、独自に判定。
    // 言語指定(match)がなく、かつコード文字列に改行(\n)が含まれていない場合をインラインとみなす。
    const isInline = inline ?? (!match && !codeString.includes("\n"));

    // 1. インラインコードの場合
    if (isInline) {
        return (
            <code
                className="bg-gray-100 text-gray-800 px-1.5 py-0.5 rounded text-sm font-mono mx-0.5 break-all"
                {...props}>
                {children}
            </code>
        );
    }

    // 2. Mermaidの場合
    if (lang === "mermaid") {
        return <MermaidPreview code={codeString} />;
    }

    // 共通のコピー処理
    const handleCopy = async () => {
        await navigator.clipboard.writeText(codeString);
        setIsCopied(true);
        setTimeout(() => setIsCopied(false), 2000);
    };

    // 3. シンタックスハイライト（ヘッダー付きブロック）
    if (match) {
        return (
            <div className="my-4 rounded-lg border border-gray-200 overflow-hidden bg-gray-50">
                {/* ヘッダー部分 */}
                <div className="flex items-center justify-between px-3 py-1.5 bg-gray-100 border-b border-gray-200">
                    <span className="text-xs font-medium text-gray-600 select-none">{lang}</span>
                    <button
                        onClick={handleCopy}
                        className="flex items-center gap-1.5 text-xs text-gray-500 hover:text-blue-600 transition-colors"
                        title="コードをクリップボードにコピー">
                        {isCopied ? (
                            <>
                                <Check size={14} className="text-green-600" />
                                <span className="text-green-600 font-medium">Copied!</span>
                            </>
                        ) : (
                            <>
                                <Copy size={14} />
                                <span>Copy</span>
                            </>
                        )}
                    </button>
                </div>

                {/* コード本文 */}
                <SyntaxHighlighter
                    {...props}
                    style={vs}
                    language={lang}
                    PreTag="div"
                    customStyle={{
                        margin: 0,
                        padding: "1rem",
                        backgroundColor: "transparent",
                        border: "none",
                    }}
                    codeTagProps={{
                        style: {
                            backgroundColor: "transparent",
                            padding: 0, // CSS側のパディングを打ち消す
                        },
                    }}>
                    {codeString}
                </SyntaxHighlighter>
            </div>
        );
    }

    // 4. 言語指定なしのブロックコード（フォールバック）
    // ここに来るのは「言語指定はないが、複数行ある」場合
    return (
        <pre className="p-4 my-4 rounded-lg bg-gray-100 overflow-auto border border-gray-200 text-sm font-mono">
            <code className={className} {...props}>
                {children}
            </code>
        </pre>
    );
};
</file>

<file path="frontend/components/ui/Mermaid.tsx">
"use client";

import React, { useEffect, useRef, useState } from "react";
import mermaid from "mermaid";
import { Download, Check } from "lucide-react"; // アイコン用

// mermaidの初期設定
mermaid.initialize({
    startOnLoad: false,
    theme: "default",
    securityLevel: "loose",
    fontFamily: "sans-serif",
    flowchart: { htmlLabels: false }, // HTMLラベルを無効化 --> ダウンロード時のセキュリティ制限に対応
});

interface MermaidProps {
    code: string;
}

const Mermaid = ({ code }: MermaidProps) => {
    const ref = useRef<HTMLDivElement>(null);
    const [isCopied, setIsCopied] = useState(false);
    const [renderId, setRenderId] = useState(""); // ユニークID用

    // コードが変わるたびにユニークなIDを生成（Mermaidのキャッシュ対策）
    useEffect(() => {
        setRenderId(`mermaid${Math.random().toString(36).substring(2, 9)}`);
    }, [code]);

    useEffect(() => {
        if (ref.current && renderId) {
            // 既存のSVGをクリア
            ref.current.innerHTML = "";

            // 一時的な要素を作成して描画させる
            // mermaid.render(id, text, container?) APIを使用
            mermaid
                .render(renderId, code)
                .then(({ svg }) => {
                    if (ref.current) {
                        ref.current.innerHTML = svg;
                    }
                })
                .catch((e) => {
                    console.error("Mermaid render error:", e);
                    if (ref.current)
                        if (ref.current)
                            ref.current.innerHTML = `<p class="text-red-500 text-sm p-2">Rendering Error: ${e.message}</p>`;
                });
        }
    }, [code, renderId]);

    // 画像としてダウンロードする関数
    const handleDownload = () => {
        if (!ref.current) return;
        const svgElement = ref.current.querySelector("svg");
        if (!svgElement) return;

        // 1. SVGデータを文字列化
        const serializer = new XMLSerializer();
        let svgString = serializer.serializeToString(svgElement);

        // 2. SVGをBase64エンコード
        const svgBase64 =
            "data:image/svg+xml;base64," + btoa(unescape(encodeURIComponent(svgString)));

        // 3. Canvasに描画
        const img = new Image();
        img.onload = () => {
            const canvas = document.createElement("canvas");
            const scale = 2; // 解像度を2倍（高画質化）

            // 【修正ポイント】viewBox属性から正確なサイズとアスペクト比を取得
            let width = 0;
            let height = 0;
            const viewBox = svgElement.getAttribute("viewBox");

            if (viewBox) {
                // viewBox = "min-x min-y width height" の形式
                const parts = viewBox.split(/\s+/).map(parseFloat);
                if (parts.length === 4) {
                    width = parts[2];
                    height = parts[3];
                }
            }

            // フォールバック（viewBoxがない場合）
            if (width === 0 || height === 0) {
                const rect = svgElement.getBoundingClientRect();
                width = rect.width;
                height = rect.height;
            }

            // 正確なアスペクト比でCanvasサイズを設定
            canvas.width = width * scale;
            canvas.height = height * scale;

            const ctx = canvas.getContext("2d");
            if (!ctx) return;

            // 背景を白で塗りつぶす
            ctx.fillStyle = "#ffffff";
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // 画像を描画（Canvasサイズに合わせてスケーリングされる）
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

            try {
                // 4. PNG変換とダウンロード
                const pngUrl = canvas.toDataURL("image/png");
                const downloadLink = document.createElement("a");
                downloadLink.href = pngUrl;
                downloadLink.download = `chart-${new Date().getTime()}.png`;
                document.body.appendChild(downloadLink);
                downloadLink.click();
                document.body.removeChild(downloadLink);

                setIsCopied(true);
                setTimeout(() => setIsCopied(false), 2000);
            } catch (e) {
                console.error("Canvas export failed:", e);
                alert("画像の保存に失敗しました。セキュリティ制限の可能性があります。");
            }
        };

        // 画像ソースにBase64を設定
        img.src = svgBase64;
    };

    return (
        <div className="relative group my-4">
            <div
                className="mermaid flex justify-center py-6 bg-white border border-gray-200 rounded-lg shadow-sm overflow-x-auto"
                ref={ref}
            />
            <div className="absolute top-2 right-2 opacity-0 group-hover:opacity-100 transition-opacity duration-200">
                <button
                    onClick={handleDownload}
                    className="p-1.5 bg-gray-100 hover:bg-white text-gray-500 hover:text-blue-600 rounded border border-gray-200 shadow-sm transition-colors"
                    title="PNG画像として保存">
                    {isCopied ? <Check size={16} /> : <Download size={16} />}
                </button>
            </div>
        </div>
    );
};

export default Mermaid;
</file>

<file path="frontend/styles/markdown_style.css">
/*
    ============================================================
    Markdownのスタイルを適用するCSS (LLM出力テキスト, メモ機能など)
    ============================================================
*/

/* 見出し */
.markdown h1 {
    font-size: 1.5rem;
    font-weight: bold;
    margin: 1.75rem 0 1rem;
}
.markdown h2 {
    font-size: 1.25rem;
    font-weight: bold;
    margin: 1.75rem 0 0.5rem;
}
.markdown h3 {
    font-size: 1rem;
    font-weight: bold;
    margin: 1.75rem 0 0.5rem;
}
.markdown h4 {
    font-size: 1rem;
    font-weight: bold;
    margin: 1.75rem 0 0.5rem;
}
.markdown h5 {
    font-size: 1rem;
    font-weight: bold;
    margin: 1.75rem 0 0.5rem;
}
.markdown h6 {
    font-size: 1rem;
    font-weight: bold;
    margin: 1.75rem 0 0.5rem;
}
/* 基本書式 */
.markdown p {
    margin-bottom: 1rem;
}
.markdown hr {
    border-top: 1px solid #c4c7c5;
    margin: 0.5rem 0;
}
/* リスト */
.markdown ul {
    padding-left: 1.6875rem;
    margin: 0.5rem 0 1rem;
}
.markdown ol {
    padding-left: 1.6875rem;
    margin: 0.5rem 0 1rem;
}
.markdown li {
    padding-left: 0.25rem;
    margin-bottom: 0.5rem;
    list-style: inside;
    list-style-position: outside;
}
.markdown ul li p {
    padding-left: 0.025rem;
    margin: 0.5rem 0;
}
/* コードブロック */
.markdown pre,
.markdown code {
    background: #f0f4f9;
    border-radius: 0.5rem;
    padding: 0.5rem;
    font-family: "Fira Mono", "Menlo", "Consolas", monospace;
    font-size: 0.95em;
}
.markdown pre {
    overflow-x: auto;
}
.markdown code {
    padding: 0.2em 0.4em;
}
/* テーブル */
.markdown table {
    border-collapse: collapse;
}
.markdown th {
    padding: 0.5rem;
    font-weight: 700;
    border: 1px solid #d6e3ed;
    background-color: #edf2f7;
}
.markdown td {
    padding: 0.5rem;
    border: 1px solid #d6e3ed;
    background-color: #fff;
}

.citation {
    font-size: 0.75em;
    color: #6b7280; /* gray-500 */
    opacity: 0.65;
    margin-left: 0.25em;
    white-space: nowrap;
    cursor: default;
}

.citation:hover {
    opacity: 1;
    color: #2563eb; /* blue-600 */
}
</file>

<file path="backend/.env.example">
FRONTEND_URL = "http://localhost:3000"
HF_TOKEN = "your_HT_TOKEN"
</file>

<file path="backend/.python-version">
3.12
</file>

<file path="backend/Dockerfile">
# backend/Dockerfile

## ベースイメージ ##
FROM python:3.12-slim

# OpenCV/RapidOCRに必要なシステムライブラリをインストール
RUN apt-get update && apt-get install -y \
    libgl1 \
    libglib2.0-0 \
    && rm -rf /var/lib/apt/lists/*

## 作業ディレクトリを設定 ##
WORKDIR /app

## uvをインストール ##
COPY --from=ghcr.io/astral-sh/uv:latest /uv /usr/local/bin/uv

## uvのvenv作成場所を明示 ##
ENV UV_PROJECT_ENVIRONMENT=/app/.venv

## 依存関係定義のみ先にコピー ##
COPY pyproject.toml uv.lock ./

## 依存関係のインストール ##
# --frozenでlockファイルを厳密に再現
RUN uv sync --frozen --no-dev

## アプリのコードをコピー ##
COPY . .

## FastAPI 開発サーバーのポート（明示的に記載） ##
EXPOSE 8000

## コンテナ起動時に実行するコマンド ##
CMD ["uv", "run", "uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000", "--reload"]
</file>

<file path="backend/pyproject.toml">
[project]
name = "academic-reader-backend"
version = "0.1.0"
description = "Academic Paper Reader powered by Docling"
requires-python = ">=3.12"
dependencies = [
    # APIサーバー関連
    "fastapi>=0.128.0",
    "uvicorn>=0.40.0",
    "python-multipart>=0.0.21", # PDFファイルのアップロード受け取りに必須
    "dotenv>=0.9.9",            # .env読み込み用
    
    # Docling & AIモデル関連
    "docling>=2.66.0",
    "torch>=2.6.0",             # GPUを用いた高速処理用
    "torchvision>=0.21.0",
    "rapidocr-onnxruntime>=1.4.4", # Doclingの日本語OCRエンジン用
]

[[tool.uv.index]]
name = "pytorch-cu124"
url = "https://download.pytorch.org/whl/cu124"
explicit = true

[tool.uv.sources]
torch = { index = "pytorch-cu124" }
torchvision = { index = "pytorch-cu124" }

[tool.ruff]
line-length = 120
</file>

<file path="backend/src/core/config.py">
# backend/src/core/config.py

import os
from pathlib import Path

from dotenv import load_dotenv

# .envファイル読み込み
load_dotenv()

# フロントエンド側のURL
FRONTEND_URL = os.getenv("FRONTEND_URL")

# HuggingFace TOKEN（Doclingで内部的に使用される可能性を考慮）
HF_TOKEN = os.getenv("HF_TOKEN")

# プロジェクトのルートパス
PROJECT_ROOT = Path(__file__).resolve().parent.parent.parent
# 静的ファイル
STATIC_BASE_PATH = PROJECT_ROOT / "storage"
STATIC_BASE_URL = "/static"

# 一時ファイルを削除するか
CLEANUP_ON_EXIT = "true"
</file>

<file path="backend/src/core/model_setup.py">
# backend/src/core/model_setup.py

from docling.document_converter import DocumentConverter

def ensure_models_downloaded():
    """起動時にモデルが存在するか確認（Docling）"""
    try:
        # 軽量な初期化テスト（実際のPDFは使わない）
        __ = DocumentConverter()
        print("[Docling] ✓ Models are ready.")
        return True
    except Exception:
        # モデル未ダウンロードの場合のメッセージ
        print("[Docling] ⚠ Models will be downloaded on first use.")
        print("         (This may take a few minutes on first request)")
        return False
</file>

<file path="backend/src/services/academic/academic_api.py">
# backend/src/services/academic/academic_api.py

from typing import List

from fastapi import APIRouter, File, HTTPException, UploadFile
from pydantic import BaseModel

from src.services.academic.academic_store import build_academic_figure_url, save_academic_data
from src.services.academic.supports.academic_parser import extract_content_from_pdf

router = APIRouter(prefix="/api/academic", tags=["学術論文(Academic)"])


# 画像の型
class AcademicImage(BaseModel):
    id: str
    label: str
    url: str


# レスポンスモデル
class AcademicParseResponse(BaseModel):
    filename: str
    text_length: int
    content: str
    images: List[AcademicImage]  # 追加


@router.post("/parse", response_model=AcademicParseResponse)
async def parse_academic_pdf(file: UploadFile = File(...)):
    """
    アップロードされた学術論文PDFからテキストを抽出する
    Doclingを使用して高精度な構造解析を実行
    """
    # バリデーション
    if file.content_type != "application/pdf":
        raise HTTPException(status_code=400, detail="PDFファイルのみ対応しています")

    # ファイル読み込み
    content = await file.read()

    # ファイルサイズチェック（50MB制限）
    MAX_SIZE = 50 * 1024 * 1024
    if len(content) > MAX_SIZE:
        raise HTTPException(status_code=413, detail=f"ファイルサイズが上限({MAX_SIZE // 1024 // 1024}MB)を超えています")

    # Doclingでパース（例外は自動的にHTTPExceptionに変換される）
    try:
        # 抽出実行（辞書を返す）
        result_data = extract_content_from_pdf(content)
        markdown_text = result_data["markdown"]
        pil_images = result_data["images"]

        # 保存処理
        doc_id = save_academic_data(markdown_text, pil_images)

        # レスポンス用画像データ作成
        # save_academic_dataの実装に合わせてURLを生成
        response_images = []
        for idx in range(1, len(pil_images) + 1):
            filename = f"fig_{idx:03d}.png"
            response_images.append(
                {"id": f"fig_{idx:03d}", "label": f"Figure {idx}", "url": build_academic_figure_url(doc_id, filename)}
            )

    except Exception as e:
        import traceback

        traceback.print_exc()
        raise HTTPException(status_code=500, detail=f"PDF解析エラー: {str(e)}")

    return {
        "filename": file.filename,
        "text_length": len(markdown_text),
        "content": markdown_text,
        "images": response_images,
    }
</file>

<file path="backend/src/services/academic/academic_store.py">
# backend/src/services/academic/academic_store.py

import json
import shutil
from pathlib import Path
from typing import Any, List
from uuid import uuid4

from src.core.config import STATIC_BASE_PATH, STATIC_BASE_URL

# ==========================================
# 1. データ管理（ファイルベース）
# ==========================================


def _get_base_dir(doc_id: str) -> Path:
    """IDごとのベースディレクトリを取得"""
    return STATIC_BASE_PATH / "academic" / doc_id


def save_academic_data(markdown_text: str, images: List[Any]) -> str:
    """
    解析結果（Markdownと画像）を保存する
    Args:
        markdown_text (str): 抽出されたMarkdown
        images (List): PIL Imageオブジェクトのリスト
    Returns:
        str: 生成されたID
    """
    doc_id = str(uuid4())
    base_dir = _get_base_dir(doc_id)
    figure_dir = base_dir / "figures"

    # ディレクトリ作成
    base_dir.mkdir(parents=True, exist_ok=True)
    figure_dir.mkdir(parents=True, exist_ok=True)

    # 1. Markdown保存
    with open(base_dir / "content.md", "w", encoding="utf-8") as f:
        f.write(markdown_text)

    # 2. 画像保存
    saved_images_meta = []
    for idx, img in enumerate(images, 1):
        filename = f"fig_{idx:03d}.png"
        save_path = figure_dir / filename

        # PNGとして保存
        img.save(save_path, format="PNG")

        saved_images_meta.append(
            {
                "id": f"fig_{idx:03d}",
                "label": f"Figure {idx}",  # 論文らしく Figure 表記
                "filename": filename,
            }
        )

    # メタデータ保存（画像リストなど）
    meta = {"id": doc_id, "images": saved_images_meta}
    with open(base_dir / "meta.json", "w", encoding="utf-8") as f:
        json.dump(meta, f, ensure_ascii=False, indent=2)

    return doc_id


# ==========================================
# 2. アクセス用URL生成
# ==========================================


def build_academic_figure_url(doc_id: str, filename: str) -> str:
    # URL: /static/academic/{id}/figures/{filename}
    return f"{STATIC_BASE_URL}/academic/{doc_id}/figures/{filename}"


# ==========================================
# 3. クリーンアップ
# ==========================================


def cleanup_temp_academic_files():
    target_dir = STATIC_BASE_PATH / "academic"
    if target_dir.exists():
        try:
            shutil.rmtree(target_dir)
            print(f"[Academic] Cleanup: Deleted {target_dir}")
        except Exception as e:
            print(f"[Academic] Cleanup Error: {e}")
</file>

<file path="backend/src/services/academic/supports/academic_parser.py">
# backend/src/services/academic/supports/academic_parser.py

import io
from typing import Any, Dict

import torch
from docling.datamodel.base_models import InputFormat
from docling.datamodel.document import PictureItem, TableItem
from docling.datamodel.pipeline_options import PdfPipelineOptions, RapidOcrOptions
from docling.document_converter import DocumentConverter, PdfFormatOption

# グローバルでコンバーターを保持
_converter = None


def get_converter() -> DocumentConverter:
    """
    シングルトンパターンでコンバーターを取得
    高精度な解析オプションを設定
    """
    global _converter
    if _converter is None:
        # --- GPUが利用可能かチェック ---
        device = "cuda" if torch.cuda.is_available() else "cpu"
        print(f"[Docling] Using device: {device}")

        # --- パイプラインオプションの設定 ---
        pipeline_options = PdfPipelineOptions()

        # --- 基本機能 ---
        pipeline_options.do_ocr = True  # OCRを有効化（画像化された文字対策）
        pipeline_options.ocr_options = RapidOcrOptions(
            backend="torch"
        )  # OCRでGPUを明示的に使用するよう指定
        pipeline_options.do_table_structure = True  # 表構造解析を有効化

        # --- 論文解析向け ---
        pipeline_options.do_formula_enrichment = True  # 数式解析
        pipeline_options.generate_picture_images = True  # 図の画像抽出
        pipeline_options.generate_table_images = (
            True  # 【追加】表の画像抽出（複雑な表対策）
        )

        _converter = DocumentConverter(
            format_options={
                InputFormat.PDF: PdfFormatOption(
                    pipeline_options=pipeline_options,
                    # 数式をMarkdown内で明示的に$..$などのLatex形式で出すための設定
                )
            }
        )
    return _converter


def extract_content_from_pdf(pdf_bytes: bytes) -> Dict[str, Any]:
    """
    PDFからMarkdownと画像を抽出する

    Args:
        pdf_bytes: PDFファイルのバイナリデータ

    Returns:
        str: Markdown形式のテキスト

    Raises:
        Exception: パース失敗時
    """
    try:
        converter = get_converter()

        # 1. BytesIOから直接変換
        pdf_stream = io.BytesIO(pdf_bytes)
        # ソース名を指定
        from docling.datamodel.document import DocumentStream

        doc_stream = DocumentStream(name="input.pdf", stream=pdf_stream)

        # 変換実行
        result = converter.convert(doc_stream)

        # 2. Markdown抽出
        markdown_text = result.document.export_to_markdown()

        # 3. 画像(Picture)と表(Table)の画像を両方抽出する
        extracted_images = []
        for element, _level in result.document.iterate_items():
            # 図(PictureItem) または 表(TableItem) を対象にする
            if isinstance(element, (PictureItem, TableItem)):
                # element.image.pil_image に PIL形式で格納
                if element.image and element.image.pil_image:
                    extracted_images.append(element.image.pil_image)

        return {"markdown": markdown_text, "images": extracted_images}

    except Exception as e:
        print(f"[Docling] PDF parsing error: {e}")
        raise Exception(f"PDF解析に失敗しました: {str(e)}")
</file>

<file path="docker-compose.yml">
# docker-compose.yml

services:
    backend:
        # `./backend/Dockerfile` を使ってイメージをビルド
        build: ./backend
        container_name: academic-reader-backend
        ## ポートマッピング ##
        ports:
            - "8000:8000" # `http://localhost:8000` でアクセスできる
        ## ボリュームマウント ##
        volumes:
            - ./backend:/app
            # .venv は Docker volume に切り出す（ホストとの環境分離）
            - backend-venv:/app/.venv
            # Doclingモデル(HuggingFace)のキャッシュを永続化
            - model-cache:/root/.cache/huggingface
        ## 環境 ##
        environment:
            - ENV=development # 明示
        deploy:
            resources:
                reservations:
                    devices:
                        - driver: nvidia
                          count: 1
                          capabilities: [gpu]
        ## 実行コマンドの明示（常にこちらで実行する） ##
        command: uv run uvicorn main:app --host 0.0.0.0 --port 8000 --reload

    frontend:
        # `./frontend/Dockerfile` を使ってイメージをビルド
        build: ./frontend
        container_name: academic-reader-frontend
        ## ポートマッピング ##
        ports:
            - "3000:3000" # `http://localhost:3000` でアクセスできる
        ## ボリュームマウント ##
        # ホストの汚染を防ぐため、ホストのパスを指定せず、コンテナ専用のボリュームにする
        volumes:
            - ./frontend:/app
            - /app/node_modules
        ## 環境 ##
        environment:
            - NODE_ENV=development # 明示
            # ブラウザから叩くURL --> localhost:8000 を指定
            - NEXT_PUBLIC_API_URL=http://localhost:8000
            - WATCHPACK_POLLING=true # ホットリロード安定化
        ## 依存 ##
        # `cont-backend` コンテナを起動してから `cont-frontend` を起動する
        depends_on:
            - backend
        # 実行コマンドを明示
        command: npm run dev

volumes:
    backend-venv:
    model-cache:
</file>

<file path="frontend/.gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# env files (can opt-in for committing if needed)
.env

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts
</file>

<file path="frontend/app/globals.css">
/* frontend/app/globals.css */

@import "tailwindcss";

:root {
    --background: #ffffff;
    --foreground: #171717;
}

@theme inline {
    --color-background: var(--background);
    --color-foreground: var(--foreground);
    --font-sans: var(--font-geist-sans);
    --font-mono: var(--font-geist-mono);
}

@media (prefers-color-scheme: dark) {
    :root {
        --background: #0a0a0a;
        --foreground: #ededed;
    }
}

body {
    background: var(--background);
    color: var(--foreground);
    font-family: Arial, Helvetica, sans-serif;
}
</file>

<file path="frontend/app/layout.tsx">
// frontend/app/layout.tsx

import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import "./globals.css";
import { Header } from "@/components/layout/Header";

const geistSans = Geist({
    variable: "--font-geist-sans",
    subsets: ["latin"],
});

const geistMono = Geist_Mono({
    variable: "--font-geist-mono",
    subsets: ["latin"],
});

export const metadata: Metadata = {
    title: "Academic Reader",
    description: "学術論文リーダー",
};

export default function RootLayout({
    children,
}: Readonly<{
    children: React.ReactNode;
}>) {
    return (
        <html lang="ja" suppressHydrationWarning>
            <body
                suppressHydrationWarning={true}
                className={`${geistSans.variable} ${geistMono.variable} antialiased
                flex flex-col h-screen bg-linear-to-br from-white via-white to-white
                `}>
                    <Header />
                <main className="relative px-6 py-8 min-w-0">
                    {children}
                </main>
            </body>
        </html>
    );
}
</file>

<file path="frontend/app/page.tsx">
// frontend/app/page.tsx

"use client";

import { CopyButton } from "@/components/ui/CopyButton";
import { ImageModal } from "@/components/ui/ImageModal";
import MarkdownViewer from "@/components/ui/MarkdownViewer";
import {
    AlertCircle,
    File,
    FileText,
    Image as ImageIcon,
    Loader2,
    PanelRightClose,
    PanelRightOpen,
    RotateCcw,
    Upload,
    Download,
} from "lucide-react";
import { useEffect, useMemo, useState } from "react";

// 型定義更新
type AcademicImage = {
    id: string;
    label: string;
    url: string;
};

type ParseResponse = {
    filename: string;
    text_length: number;
    content: string;
    images: AcademicImage[];
};

export default function AcademicReaderPage() {
    const [file, setFile] = useState<File | null>(null);
    const [isLoading, setIsLoading] = useState(false);
    const [result, setResult] = useState<ParseResponse | null>(null);
    const [error, setError] = useState<string | null>(null);
    const [showImages, setShowImages] = useState(true); // 画像表示トグル
    // --- モーダル用State ---
    const [selectedImage, setSelectedImage] = useState<{ url: string; label: string } | null>(null);
    // --- 表示モードの切り替え（PDFは精度確認用など） ---
    const [viewMode, setViewMode] = useState<"markdown" | "pdf">("markdown");

    // --- PDF表示用のURL生成とクリーンアップ ---
    const pdfUrl = useMemo(() => {
        if (!file) return null;
        return URL.createObjectURL(file);
    }, [file]);

    useEffect(() => {
        // コンポーネントのアンマウント時やファイル変更時にURLを解放
        return () => {
            if (pdfUrl) URL.revokeObjectURL(pdfUrl);
        };
    }, [pdfUrl]);

    const handleUpload = async () => {
        if (!file) return;
        setIsLoading(true);
        setError(null);

        const formData = new FormData();
        formData.append("file", file);

        try {
            const apiUrl = process.env.NEXT_PUBLIC_API_URL || "http://localhost:8000";
            const response = await fetch(`${apiUrl}/api/academic/parse`, {
                method: "POST",
                body: formData,
            });

            if (!response.ok) {
                const errData = await response.json();
                throw new Error(errData.detail || "解析に失敗しました");
            }

            const data: ParseResponse = await response.json();
            setResult(data);
            setShowImages(true); // 解析完了時は画像を表示
            setViewMode("markdown"); // 解析完了後はMarkdown表示に戻す
        } catch (err: any) {
            setError(err.message);
        } finally {
            setIsLoading(false);
        }
    };

    // ダウンロード機能
    const handleDownload = () => {
        if (!result || !result.content) return;
        const blob = new Blob([result.content], { type: "text/markdown" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `${result.filename}.md`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    };

    // リセット
    const handleReset = () => {
        setFile(null);
        setResult(null);
        setError(null);
        setSelectedImage(null); // 選択画像もクリア
        setViewMode("markdown");
    };

    // 結果表示モード
    if (result) {
        const hasImages = result.images.length > 0;

        return (
            <div className="h-full flex flex-col max-w-7xl mx-auto">
                {/* --- モーダル配置 --- */}
                <ImageModal
                    isOpen={!!selectedImage}
                    onClose={() => setSelectedImage(null)}
                    imageUrl={
                        selectedImage
                            ? `${process.env.NEXT_PUBLIC_API_URL}${selectedImage.url}`
                            : null
                    }
                    altText={selectedImage?.label}
                />
                {/* ヘッダー */}
                <div className="flex items-center justify-between mb-4 pb-3 border-b border-gray-200">
                    <div>
                        <h2 className="text-xl font-bold text-gray-800 flex items-center gap-2">
                            <FileText className="text-blue-600" />
                            {result.filename}
                        </h2>
                        <div className="text-xs text-gray-500 mt-1 font-mono">
                            文字数: {result.text_length.toLocaleString()}
                        </div>
                    </div>

                    <div className="flex gap-4 items-center">
                        {/* --- 表示モード切り替えトグル --- */}
                        <div className="bg-gray-100 p-1 rounded-lg flex items-center">
                            <button
                                onClick={() => setViewMode("markdown")}
                                className={`flex items-center gap-1.5 px-3 py-1.5 text-xs font-medium rounded-md transition-all ${viewMode === "markdown"
                                        ? "bg-white text-blue-600 shadow-sm"
                                        : "text-gray-500 hover:text-gray-700"
                                    }`}>
                                <FileText size={14} />
                                解析結果
                            </button>
                            <button
                                onClick={() => setViewMode("pdf")}
                                className={`flex items-center gap-1.5 px-3 py-1.5 text-xs font-medium rounded-md transition-all ${viewMode === "pdf"
                                        ? "bg-white text-blue-600 shadow-sm"
                                        : "text-gray-500 hover:text-gray-700"
                                    }`}>
                                <File size={14} />
                                原文PDF
                            </button>
                        </div>

                        <div className="flex items-center gap-2 border-l border-gray-200 pl-4">
                            <div
                                className={
                                    viewMode === "pdf" ? "opacity-50 pointer-events-none" : ""
                                }>
                                <CopyButton text={result.content} label="全文コピー" />
                            </div>
                            <button
                                onClick={handleDownload}
                                className="flex items-center gap-2 px-3 py-1.5 text-xs font-medium rounded-md border border-slate-200 bg-white text-slate-500 hover:bg-slate-50 hover:text-slate-700 transition-all">
                                <Download size={14} /> ダウンロード
                            </button>

                            {/* 画像トグルボタン */}
                            {hasImages && (
                                <button
                                    onClick={() => setShowImages(!showImages)}
                                    className="flex items-center gap-2 px-3 py-1.5 text-xs font-medium rounded-md border bg-white text-slate-500 border-slate-200 hover:bg-slate-50 transition-all"
                                    title={showImages ? "画像を非表示にする" : "画像を表示する"}>
                                    {showImages ? (
                                        <PanelRightClose size={16} />
                                    ) : (
                                        <PanelRightOpen size={16} />
                                    )}
                                    {showImages ? "画像非表示" : "画像を表示"}
                                </button>
                            )}

                            <button
                                onClick={handleReset}
                                className="flex items-center gap-2 px-3 py-2 text-sm rounded-2xl text-gray-600 hover:bg-gray-100/50 transition-colors">
                                <RotateCcw size={16} />
                            </button>
                        </div>
                    </div>
                </div>

                <div className="flex flex-1 gap-6 overflow-hidden overflow-x-hidden">
                    {/* 左カラム: Markdown本文 OR PDFビューワー */}
                    <div
                        className={`
                            flex-1 relative
                            ${viewMode === "markdown"
                                ? "overflow-y-auto pb-20 pr-2"
                                : "h-full overflow-hidden"
                            }
                        `}>
                        {viewMode === "markdown" ? (
                            // --- Markdown表示モード ---
                            <MarkdownViewer content={result.content} />
                        ) : (
                            // --- PDF表示モード ---
                            <div className="w-full h-full bg-gray-100 rounded-lg overflow-hidden border border-gray-300">
                                {pdfUrl ? (
                                    <iframe
                                        src={`${pdfUrl}#view=FitH&navpanes=0`}
                                        className="w-full h-full border-none"
                                        title="PDF Preview"
                                    />
                                ) : (
                                    <div className="flex items-center justify-center h-full text-gray-400">
                                        PDFを表示できません
                                    </div>
                                )}
                            </div>
                        )}
                    </div>

                    {/* 右カラム: 画像一覧 */}
                    {hasImages && showImages && (
                        <div className="w-96 shrink-0 flex flex-col border-l border-gray-200 pl-4 -mr-6 pr-6 pt-2 transition-all">
                            <div className="flex items-center justify-between mb-4">
                                <h3 className="font-semibold text-gray-700 flex items-center gap-2">
                                    <ImageIcon size={18} />
                                    抽出画像 ({result.images.length})
                                </h3>
                                <button
                                    onClick={() => setShowImages(false)}
                                    className="p-1 text-gray-400 hover:text-gray-700 hover:bg-gray-200 rounded transition-colors"
                                    title="画像を非表示にする">
                                    <PanelRightClose size={16} />
                                </button>
                            </div>

                            <div className="flex-1 overflow-y-auto space-y-6 pr-2 pb-20">
                                {result.images.map((img) => (
                                    <div
                                        key={img.id}
                                        className="bg-white border border-gray-200 rounded-lg p-3 shadow-sm hover:shadow-md transition-shadow">
                                        <div
                                            className="aspect-auto bg-gray-50 rounded-md overflow-hidden mb-2 flex items-center justify-center relative group cursor-pointer"
                                            onClick={() =>
                                                setSelectedImage({ url: img.url, label: img.label })
                                            } // モーダルを開く
                                        >
                                            {/* eslint-disable-next-line @next/next/no-img-element */}
                                            <img
                                                src={`${process.env.NEXT_PUBLIC_API_URL}${img.url}`}
                                                alt={img.label}
                                                className="max-w-full max-h-60 object-contain hover:scale-105 transition-transform duration-200"
                                            />
                                            <div className="absolute inset-0 bg-black/0 group-hover:bg-black/5 transition-colors flex items-center justify-center">
                                                <div className="bg-black/50 text-white text-xs px-2 py-1 rounded opacity-0 group-hover:opacity-100 transition-opacity">
                                                    拡大表示
                                                </div>
                                            </div>
                                        </div>
                                        <div className="flex items-center justify-between px-1">
                                            <span className="text-sm font-bold text-gray-700">
                                                {img.label}
                                            </span>
                                        </div>
                                    </div>
                                ))}
                            </div>
                        </div>
                    )}
                </div>
            </div>
        );
    }

    // アップロード待機モード
    return (
        <div className="h-full flex flex-col items-center justify-center max-w-2xl mx-auto p-6 animate-in fade-in zoom-in-95 duration-300">
            <div className="mb-8 text-center">
                <h1 className="text-2xl font-bold text-gray-800 mb-2">学術論文リーダー</h1>
                <p className="text-gray-500">
                    PDFをアップロードして、高精度な構造解析（数式・表・図版）を実行します
                </p>
            </div>

            <div className="w-full border-2 border-dashed rounded-2xl p-12 text-center bg-white hover:border-gray-400 transition-all">
                <input
                    type="file"
                    accept=".pdf"
                    onChange={(e) => setFile(e.target.files?.[0] || null)}
                    className="hidden"
                    id="file-input"
                />
                <label htmlFor="file-input" className="cursor-pointer">
                    <div className="flex flex-col items-center gap-4">
                        <div className="w-16 h-16 rounded-full flex items-center justify-center bg-gray-100">
                            {file ? (
                                <FileText className="w-8 h-8 text-green-600" />
                            ) : (
                                <Upload className="w-8 h-8 text-gray-400" />
                            )}
                        </div>
                        {file ? (
                            <div>
                                <p className="text-lg font-medium text-gray-800">{file.name}</p>
                                <p className="text-sm text-gray-500 mt-1">
                                    {(file.size / 1024 / 1024).toFixed(2)} MB
                                </p>
                            </div>
                        ) : (
                            <p className="text-lg font-medium text-gray-700">PDFファイルを選択</p>
                        )}
                    </div>
                </label>
            </div>

            {error && (
                <div className="mt-6 p-4 w-full bg-red-50 border border-red-200 rounded-xl flex items-center gap-3 text-red-700 animate-in slide-in-from-top-2">
                    <AlertCircle size={20} />
                    <span className="text-sm font-medium">{error}</span>
                </div>
            )}

            {file && (
                <button
                    onClick={handleUpload}
                    disabled={isLoading}
                    className="mt-8 w-full max-w-sm py-3 px-6 bg-blue-600 text-white font-semibold rounded-xl hover:bg-blue-700 disabled:opacity-50 transition-all shadow-md flex items-center justify-center gap-2">
                    {isLoading ? (
                        <>
                            <Loader2 className="animate-spin" />
                            解析中...
                        </>
                    ) : (
                        <>
                            <FileText />
                            解析を開始する
                        </>
                    )}
                </button>
            )}
        </div>
    );
}
</file>

<file path="frontend/Dockerfile">
# frontend/Dockerfile

## ベースイメージ ##
FROM node:20-alpine

## 作業ディレクトリを設定 ##
WORKDIR /app

## package.json と lock ファイルを先にコピー ##
COPY package*.json ./

## 依存関係をインストール ##
RUN npm install

## アプリのコードをコピー ##
COPY . .

## Next.js 開発サーバーのポート（明示的に記載） ##
EXPOSE 3000

## コンテナ起動時に実行するコマンド ##
CMD ["npm", "run", "dev"]
</file>

<file path="frontend/eslint.config.mjs">
import { defineConfig, globalIgnores } from "eslint/config";
import nextVitals from "eslint-config-next/core-web-vitals";
import nextTs from "eslint-config-next/typescript";

const eslintConfig = defineConfig([
    ...nextVitals,
    ...nextTs,
    // Override default ignores of eslint-config-next.
    globalIgnores([
        // Default ignores of eslint-config-next:
        ".next/**",
        "out/**",
        "build/**",
        "next-env.d.ts",
    ]),
]);

export default eslintConfig;
</file>

<file path="frontend/next.config.ts">
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
    /* config options here */
};

export default nextConfig;
</file>

<file path="frontend/package.json">
{
    "name": "academic-reader-frontend",
    "version": "0.1.0",
    "private": true,
    "scripts": {
        "dev": "next dev",
        "build": "next build",
        "start": "next start",
        "lint": "eslint",
        "api:gen": "openapi-typescript http://localhost:8000/openapi.json -o ./types/api.ts"
    },
    "dependencies": {
        "lucide-react": "^0.575.0",
        "mermaid": "^11.12.3",
        "next": "16.1.6",
        "openapi-typescript": "^7.13.0",
        "react": "19.2.3",
        "react-dom": "19.2.3",
        "react-markdown": "^10.1.0",
        "react-syntax-highlighter": "^16.1.0",
        "rehype-katex": "^7.0.1",
        "rehype-raw": "^7.0.0",
        "remark-breaks": "^4.0.0",
        "remark-gfm": "^4.0.1",
        "remark-github-blockquote-alert": "^2.0.1",
        "remark-math": "^6.0.0"
    },
    "devDependencies": {
        "@tailwindcss/postcss": "^4",
        "@types/node": "^20",
        "@types/react": "^19",
        "@types/react-dom": "^19",
        "@types/react-syntax-highlighter": "^15.5.13",
        "eslint": "^9",
        "eslint-config-next": "16.1.6",
        "tailwindcss": "^4",
        "typescript": "^5"
    }
}
</file>

<file path="frontend/postcss.config.mjs">
const config = {
    plugins: {
        "@tailwindcss/postcss": {},
    },
};

export default config;
</file>

<file path="frontend/tailwind.config.js">
// tailwind.config.js
/** @type {import('tailwindcss').Config} */
export default {
    content: [
        "./app/**/*.{js,ts,jsx,tsx}",
        "./components/**/*.{js,ts,jsx,tsx}",
        "./hooks/**/*.{js,ts,jsx,tsx}",
    ],
    theme: {
        extend: {},
    },
    plugins: [],
};
</file>

<file path="frontend/tsconfig.json">
{
    "compilerOptions": {
        "target": "ES2017",
        "lib": [
            "dom",
            "dom.iterable",
            "esnext"
        ],
        "allowJs": true,
        "skipLibCheck": true,
        "strict": true,
        "noEmit": true,
        "esModuleInterop": true,
        "module": "esnext",
        "moduleResolution": "bundler",
        "resolveJsonModule": true,
        "isolatedModules": true,
        "jsx": "react-jsx",
        "incremental": true,
        "plugins": [
            {
                "name": "next"
            }
        ],
        "paths": {
            "@/*": [
                "./*"
            ]
        }
    },
    "include": [
        "next-env.d.ts",
        "**/*.ts",
        "**/*.tsx",
        ".next/types/**/*.ts",
        ".next/dev/types/**/*.ts",
        "**/*.mts"
    ],
    "exclude": [
        "node_modules"
    ]
}
</file>

<file path="README.md">
# Academic Reader

**Academic Reader** は、学術論文のPDFを高精度に解析し、Markdownテキストと画像（図表）として抽出・表示するローカル専用のWebアプリケーションです。

強力な文書解析ライブラリである [Docling](https://github.com/DS4SD/docling) をバックエンドに採用しており、複雑な段組み、数式、表、図版を含む論文PDFを正確に構造化して読み取ることができます。

![スクリーンショット](フロントエンドのスクリーンショット添付予定)

## 開発目的

* 英語の学術論文を快適に読むために作成しました。

## 課題と解決策

* 英語の論文PDFは、ブラウザで表示してもブラウザの翻訳機能は使えず、Google翻訳などのソフトにテキストを貼り付けることで翻訳します。しかし、文字数制限もあり、不便でした。
* また、LLMに翻訳させるアプローチもありますが、トークン消費量が多く、解説もさせる場合は「翻訳」→「解説」とLLMによる情報の加工が2回行われることになり、正確である保証はありません。
* そこで、Doclingを用いてMarkdownに変換してブラウザ上に表示すれば、ブラウザの翻訳機能をそのまま利用でき、英語 <--> 日本語 を切り替えながら読み進めることが可能です。
* また、高精度なMarkdownとして出力されるため、LLMに与えるコンテキストとしても最適です。（LaTeX記法の数式や、構造化されたテーブル出力にも対応）
* 画像も抽出されているため、画像のみをダウンロードすることも可能です。（NotebookLM向けのクリーンな資料作成にも適しています）

## オフラインツール

* 技術スタックはWebアプリ向けですが、Dockerを利用しローカルサーバーを起動して利用するオフラインツールとしての運用を想定しています。
* **理由**:
  * Docklingは内部で高精度なOCRモデルを利用しており、GPUによる処理が必要。
  * クラウドでのGPUデプロイは通常と比べコストが高く、今回の処理ではそこまで高性能のGPUは不要。
  * 用途的にもWeb上に公開する必要性があまりない。

## 主な機能

* **PDFの高精度構造解析**: DoclingによるPDFの読み取り（数式、表、段落の認識）。
* **図表の自動抽出**: 論文内に含まれるFigure（図）やTable（表）を画像として自動で切り出し、サイドパネルに一覧表示。
* **Markdownビューワー**: 抽出されたテキストを、数式対応（KaTeX）のクリーンなMarkdownとして表示。
* **原文PDFプレビュー**: 解析結果と元のPDFをワンクリックで切り替えて比較確認が可能。
* **1クリックコピー**: 解析されたMarkdownの全文をクリップボードに一瞬でコピー。
* **1クリックダウンロード**: 解析されたMarkdownの全文をその場で`.md`ファイルとしてダウンロード。

## 技術スタック

* **Backend**
  * Python 3.12
  * FastAPI (APIサーバー)
  * Docling (PDF解析・OCR)
  * PyTorch (GPUアクセラレーション)
  * uv (高速なパッケージマネージャー)
* **Frontend**
  * Next.js (React)
  * Tailwind CSS
  * React Markdown / rehype-katex (Markdown・数式レンダリング)
* **Infrastructure**
  * Docker / Docker Compose

## セットアップと起動方法

本システムは、Docker環境での実行を推奨しています。コンテナ内でGPUを使用するための設定（`nvidia-container-toolkit`）が必要です。

### 1. 準備

初回起動時のみ、バックエンドの依存関係ファイル（`uv.lock`）を生成しておく必要があります。
※すでに生成済みの場合はスキップしてください。

```bash
cd backend
uv sync --frozen --no-dev
cd ..

```

### 2. 環境変数の設定

`backend` と `frontend` のディレクトリに、それぞれ環境変数ファイルを作成します。
リポジトリにある `.example` ファイルをコピーして利用してください。

```bash
# Backend
cp backend/.env.example backend/.env

# Frontend
cp frontend/.env.local.example frontend/.env.local

```

### 3. Docker Compose での起動

ルートディレクトリで以下のコマンドを実行します。

```bash
docker compose up --build

```

* バックエンド: `http://localhost:8000`
* フロントエンド: `http://localhost:3000`

> **Note**: 初回起動時は、Doclingが必要とするレイアウト解析やOCR用のモデルデータ（数GB）をHugging Faceからダウンロードするため、最初の解析に時間がかかります。モデルデータはDockerのボリューム（`model-cache`）に永続化されるため、次回以降は高速に処理されます。

## ディレクトリ構成

```text
academic-reader/
├── backend/                # FastAPI バックエンド
│   ├── src/
│   │   ├── core/           # 設定、モデル初期化
│   │   └── services/
│   │       └── academic/   # PDF解析ロジック、APIルーター
│   ├── pyproject.toml      # 依存関係定義
│   └── Dockerfile
├── frontend/               # Next.js フロントエンド
│   ├── app/                # UIページ構成
│   ├── components/         # 共通コンポーネント (MarkdownViewer, ImageModal等)
│   ├── package.json
│   └── Dockerfile
└── docker-compose.yml      # コンテナ構成定義

```
</file>

<file path=".gitignore">
# .gitignore
# Gitでバージョン管理の対象から除外したいファイルやディレクトリを指定するための設定ファイル。
# リポジトリに含める必要のないものを誤ってコミットするのを防ぐ。

# ==================================================
# プロジェクト固有の指定
# ==================================================

storage/
**/


# ↓GitHubのテンプレート由来↓
# ==================================================
# Next.js
# ==================================================

# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.js

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# local env files
.env.local
.env

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts

# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# env files (can opt-in for committing if needed)
.env

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts

# ==================================================
# Python
# ==================================================
# Byte-compiled / optimized / DLL files
__pycache__/
*.py[codz]
*$py.class

# C extensions
*.so

# Distribution / packaging
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
share/python-wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST

# PyInstaller
#  Usually these files are written by a python script from a template
#  before PyInstaller builds the exe, so as to inject date/other infos into it.
*.manifest
*.spec

# Installer logs
pip-log.txt
pip-delete-this-directory.txt

# Unit test / coverage reports
htmlcov/
.tox/
.nox/
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
*.py.cover
.hypothesis/
.pytest_cache/
cover/

# Translations
*.mo
*.pot

# Django stuff:
*.log
local_settings.py
db.sqlite3
db.sqlite3-journal

# Flask stuff:
instance/
.webassets-cache

# Scrapy stuff:
.scrapy

# Sphinx documentation
docs/_build/

# PyBuilder
.pybuilder/
target/

# Jupyter Notebook
.ipynb_checkpoints

# IPython
profile_default/
ipython_config.py

# pyenv
#   For a library or package, you might want to ignore these files since the code is
#   intended to run in multiple environments; otherwise, check them in:
# .python-version

# pipenv
#   According to pypa/pipenv#598, it is recommended to include Pipfile.lock in version control.
#   However, in case of collaboration, if having platform-specific dependencies or dependencies
#   having no cross-platform support, pipenv may install dependencies that don't work, or not
#   install all needed dependencies.
#Pipfile.lock

# UV
#   Similar to Pipfile.lock, it is generally recommended to include uv.lock in version control.
#   This is especially recommended for binary packages to ensure reproducibility, and is more
#   commonly ignored for libraries.
#uv.lock

# poetry
#   Similar to Pipfile.lock, it is generally recommended to include poetry.lock in version control.
#   This is especially recommended for binary packages to ensure reproducibility, and is more
#   commonly ignored for libraries.
#   https://python-poetry.org/docs/basic-usage/#commit-your-poetrylock-file-to-version-control
#poetry.lock
#poetry.toml

# pdm
#   Similar to Pipfile.lock, it is generally recommended to include pdm.lock in version control.
#   pdm recommends including project-wide configuration in pdm.toml, but excluding .pdm-python.
#   https://pdm-project.org/en/latest/usage/project/#working-with-version-control
#pdm.lock
#pdm.toml
.pdm-python
.pdm-build/

# pixi
#   Similar to Pipfile.lock, it is generally recommended to include pixi.lock in version control.
#pixi.lock
#   Pixi creates a virtual environment in the .pixi directory, just like venv module creates one
#   in the .venv directory. It is recommended not to include this directory in version control.
.pixi

# PEP 582; used by e.g. github.com/David-OConnor/pyflow and github.com/pdm-project/pdm
__pypackages__/

# Celery stuff
celerybeat-schedule
celerybeat.pid

# SageMath parsed files
*.sage.py

# Environments
.env
.envrc
.venv
env/
venv/
ENV/
env.bak/
venv.bak/

# Spyder project settings
.spyderproject
.spyproject

# Rope project settings
.ropeproject

# mkdocs documentation
/site

# mypy
.mypy_cache/
.dmypy.json
dmypy.json

# Pyre type checker
.pyre/

# pytype static type analyzer
.pytype/

# Cython debug symbols
cython_debug/

# PyCharm
#  JetBrains specific template is maintained in a separate JetBrains.gitignore that can
#  be found at https://github.com/github/gitignore/blob/main/Global/JetBrains.gitignore
#  and can be added to the global gitignore or merged into this file.  For a more nuclear
#  option (not recommended) you can uncomment the following to ignore the entire idea folder.
#.idea/

# Abstra
# Abstra is an AI-powered process automation framework.
# Ignore directories containing user credentials, local state, and settings.
# Learn more at https://abstra.io/docs
.abstra/

# Visual Studio Code
#  Visual Studio Code specific template is maintained in a separate VisualStudioCode.gitignore 
#  that can be found at https://github.com/github/gitignore/blob/main/Global/VisualStudioCode.gitignore
#  and can be added to the global gitignore or merged into this file. However, if you prefer, 
#  you could uncomment the following to ignore the entire vscode folder
# .vscode/

# Ruff stuff:
.ruff_cache/

# PyPI configuration file
.pypirc

# Cursor
#  Cursor is an AI-powered code editor. `.cursorignore` specifies files/directories to
#  exclude from AI features like autocomplete and code analysis. Recommended for sensitive data
#  refer to https://docs.cursor.com/context/ignore-files
.cursorignore
.cursorindexingignore

# Marimo
marimo/_static/
marimo/_lsp/
__marimo__/
</file>

<file path="backend/main.py">
# backend/main.py

import os
from contextlib import asynccontextmanager  # ライフサイクルイベント

import torch
from fastapi import FastAPI  # アプリ本体
from fastapi.staticfiles import StaticFiles  # 静的ファイルのマウント
from starlette.middleware.cors import CORSMiddleware  # ルーター登録用

# 環境変数
from src.core.config import CLEANUP_ON_EXIT, FRONTEND_URL, STATIC_BASE_PATH, STATIC_BASE_URL

# Docling
from src.core.model_setup import ensure_models_downloaded
from src.services.academic import academic_api
from src.services.academic.academic_store import cleanup_temp_academic_files

# GPUチェック
print(torch.__version__)
print("CUDA available:", torch.cuda.is_available())
print("Device count:", torch.cuda.device_count())
print("Device name:", torch.cuda.get_device_name(0) if torch.cuda.is_available() else None)

# ============================================================
# ライフサイクルイベント（起動・終了時の処理）
# ============================================================


@asynccontextmanager
async def lifespan(app: FastAPI):
    """
    アプリケーションのライフサイクル管理
    - yield前: アプリ起動時の処理
    - yield後: アプリ終了時の処理
    """

    # --- 起動時の処理 ---
    print("アプリケーションを起動しています...")
    #
    if not os.path.exists(STATIC_BASE_PATH):
        os.makedirs(STATIC_BASE_PATH, exist_ok=True)
        print(f"フォルダを作成しました{STATIC_BASE_PATH}")

    # Doclingモデルの確認
    if not ensure_models_downloaded():
        print("[Warning] Docling models not found. First request will take longer.")

    yield  # ← ここでアプリケーションが実行される

    # --- 終了時の処理 ---
    print("アプリケーションを終了しています...")
    if CLEANUP_ON_EXIT == "true":
        cleanup_temp_academic_files()  # 論文一時ファイル削除実行


# ============================================================
# アプリケーションのセットアップ
# ============================================================

app = FastAPI(
    title="Academic Reader",
    description="学術論文リーダー",
    version="1.0.0",
    lifespan=lifespan,  # ← lifespanを指定
)

# ============================================================
# マウント処理
# ============================================================

# 学術論文用ストレージ
academic_storage_dir = STATIC_BASE_PATH / "academic"
academic_storage_dir.mkdir(parents=True, exist_ok=True)

app.mount(
    f"{STATIC_BASE_URL}/academic",  # -> "/static/academic"
    StaticFiles(directory=academic_storage_dir),
    name="static_academic",
)

# ============================================================
# CORS設定（フロントエンドとの通信を許可）
# ============================================================

app.add_middleware(
    CORSMiddleware,
    allow_origins=[FRONTEND_URL],  # フロントエンド の URL を指定
    allow_credentials=True,
    allow_methods=["GET", "POST"],  # 必要なメソッドのみ許可
    allow_headers=["Content-Type", "Authorization"],  # 必要なヘッダーのみ許可
)


# ============================================================
# ルーター登録（実装順）
# ============================================================


app.include_router(academic_api.router)  # 4. academic

# ============================================================
# エンドポイント（テスト用）
# ===========================================================


@app.get("/")
def read_root():
    return {"message": "document: localhost:8000/docs"}


# uv run uvicorn main:app --host 0.0.0.0 --port 8000 --reload
</file>

</files>
